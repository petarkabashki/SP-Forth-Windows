<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>
<book>
<!-- 2006-2007 ruvim@forth.org.ru -->
<!-- $Id: hint-spf4.xml,v 1.13 2008/12/03 16:19:30 ruv Exp $ -->

<h2>Параграфы на памятку</h2>

<toc/>

<chapter id="quit"><title>Интерактивная отладка</title>
<p>Слово <w>QUIT</w> позволяет выйти в интерактивный режим
прямо в необходимом контексте — и проверить 
состояние стека, объектов, порядок поиска, выполнить вручную
оставшуюся часть слова.
Если целевым является дочерний поток (нить), тогда
в основном потоке надо сделать <w>-1 PAUSE</w> и 
обеспечить запуск <w>QUIT</w> лишь в отлаживаемом потоке.
Бывает полезно запустить <w>QUIT</w> среди процесса трансляции
файла — для отладки в текущем (особо, если глубоком) порядке поиска, вместо того, чтобы потом
устанавливать его вручную.
</p>

<p><b>Замечание.</b> Выйти из слова <w>QUIT</w> и отдать управление
дальше, в точку после его вызова — невозможно (стандартного способа нет).
Тем самым, оно сто&#769;ит своего имени.
</p>

</chapter>


<chapter id="scope"><title>Область видимости при EXPORT</title>
<p>Пример
<pre>MODULE: SomethingSupport
  INCLUDE core-implementation.f \ provide A
EXPORT
  : A action-before A action-after ; \ переопределение
  : B some-actions A ;
;MODULE
</pre></p>
<p>Здесь перекрывается обычный принцип <i>локальности</i>, — в слове <w>B</w> будет использованно
не только что определенное слово <w>A</w>, а ранее определенное из словаря <w>SomethingSupport</w>,
т.к. именно этот словарь первый в порядке поиска (то бишь, на вершине стека контекста).
</p>

<p><b>Ошибка:</b> полагать, что в новом определении будет использованно выше-определенное слово, когда это не так.</p>

<p><b>Решение:</b> ~pinka/spf/compiler/<a href="../../../spf/compiler/native-context.f">native-context.f</a>:
набор слов <w>PUSH-DEVELOP</w>, <w>BEGIN-EXPORT</w>, <w>END-EXPORT</w>, <w>DROP-DEVELOP</w> сохраняет указанный принцип локальности 
и прозрачен по стеку данных (используется управляющий стек для сохранения и восстановления контекста).
</p>

</chapter>

<chapter id="qualify"><title>Квалификация имени словарем</title>
<p>В SPF4 поддерживается синтаксис <kbd>voc::word</kbd> для квалификации имени
посредством указания словаря.
Эта фича <a href="../../../../../src/compiler/spf_translate.f">реализована</a>
через добавление словаря <kbd>voc</kbd>
в контекст (область видимости) перед трансляцией <kbd>word</kbd> и восстановление контекста сразу после этого.
Такая реализация вызывает следующие особенности:
<ol><li>
если данного слова нет в заданном словаре, оно может быть взято и из другого словаря в текущем контексте;
</li><li>
при использовании в режиме исполнения, слово <kbd>word</kbd> исполняется 
в неявно модифицированном контексте (со словарем <code>voc</code> на вершине),
что может привести к неверному связыванию, когда <kbd>word</kbd> вызывает какую-либо трансляцию;
</li><li>
в режиме исполнения не работают слова, изменяющие контекст (т.к. он автоматически восстанавливается).
</li></ol>
</p>
<p>Пример
<pre>ONLY FORTH DEFINITIONS
`worker WORDLIST-NAMED PUSH-DEVELOP
  tcp-server::load-worker  \ определено как : load-worker `worker.f full-name INCLUDED ;
DROP-DEVELOP
</pre>
  В каком контексте <kbd>worker.f</kbd> будет транслироваться?
  — со словарем <kbd>tcp-server</kbd> на вершине, и совпадающие имена из этого словаря
  будут перекрывать все новые определния!
</p>
<p><b>Ошибка:</b> упустить из виду сигнатуру стека контекста для взятого механизма.</p>

<p><b>Замечание:</b> в трансляторе ForthML работает
<a href="../../../model/trans/iword-qnative.f.xml">другая реализация</a>
данного синтаксиса,
в которой контекст не трогается вообще (но, в качестве квалификаторов поддерживаются
только слова, возвращающие wid).</p>

</chapter>


<chapter id="homonym"><title>Слова-омонимы</title>

<p>Бывает очень трудно отловить ошибку, когда вместо
ожидаемого слова в определение попадает его омоним — совпадающее по имени
другое слово.</p>
<p><b>Иллюстрация.</b> В некоторых реализациях OOP имя слова-сообщения и имя слова-обработчика совпадают
(естественно, они находятся в разных словарях).
Слово-сообщение ожидает на вершине объект и далее некоторые параметры,
а слово-обработчик ожидает только параметры (объект устанавливается косвенным образом).
С каким словом произойдет связывание при употреблении данного имени — определяется контекстом.
В такой ситуации <i>легкомысленное</i> обращении с контекстом может привести к неверному связыванию 
и очень непонятным глюкам даже при интерактивной отладке.
</p>
</chapter>


<chapter id="heap-local"><title>Хип локален для потока</title>

<p>Функции работы с памятью (<w>ALLOCATE</w>, <w>RESIZE</w>, <w>FREE</w>)
обращаются к некоторому хипу (куче).
Но, у каждого потока свой хип; взять же блок памяти
у одного хипа, а отдать другому хипу — нельзя.
</p>

<p><b>Ошибка:</b> выделить память в одном потоке, а освободить ее попросту в другом.</p>

</chapter>

<chapter id="heap-corrupt"><title>Повреждение хипа</title>

<p>Повреждение хипа часто ведет к молчаливому падению форт-системы.
Особенно сбивает с толку то, что падает «на ровном месте»,
далеко от того места, где произошло само повреждение,
и не во всяком случае.
</p><p>
Вот, устаревшая величина MAX_PATH, или ошибка в описании структуры MSG,
 — и происходит <i>переполнение буфера</i> и повреждение хипа.
Память повреждается прямо внутри системных функций, 
за недостаточностью поданного буфера.
</p>

</chapter>


<chapter id="exc-dump"><title>Дамп аппаратных исключений</title>
<p>При аппаратных исключениях выводится 
дамп с разверткой стека возвратов. 
При этом имена слов определяются через <w>WordByAddr</w>,
которое относит адрес к ближайшему именованному слову.
Поэтому, если исключение происходит во фрагменте кода
анонимного (“<w>:NONAME</w>”), или распределенного
(“<w>..:</w>”) определения, то выводится имя ближайшего
слова перед этим фрагментом кода (это может быть имя
словаря, константы, или чего угодно).
Данная особенность является одним из источников
непоняток при расшифровке дампа.
</p>
</chapter>


<chapter id="dll"><title>Относительные ссылки на DLL</title>

<p>Для подключения DLL используется системная функция <w>LoadLibrary</w>.
При разрешении имени она ищет файл по абсолютному пути,
относительно бинарника, или в системных каталогах Windows.
</p>

<p><b>Ошибка:</b> расположенный в новом месте бинарник, 
а ссылки на dll таковы, что они доступны лишь из старого места.</p>

</chapter>


<chapter id="spfbig"><title>Расширение форт-системы</title>

<p>Слово <w>SAVE</w> сохраняет форт-систему (по сути, базовое хранилище)
в новый исполнямый файл; при его запуске будут доступны все
слова, словари и данные, которые были созданы перед сохранением (кроме
временных словарей и тому подобных динамических структур).
Порожденная таким образом форт-система является расширенной и более
специализированной по отношению к родительской.
</p>

<p><b>Совет.</b> Используйте расширенные версии системы,
делая сохранение после подключения необходимых библиотек (типа <w>`spfbig.exe SAVE</w>)
или даже после сборки ядра целевого приложения (типа <w>`acTCP.exe SAVE</w>), — 
<i>чтобы обеспечить</i> экономное свертывание и развертывание,
быстрый запуск и при этом оставить возможность модификации и эволюции приложения
(живые исходники).
</p>

<p><b>Фичи.</b> Легко выделить необходимое из среды разработки:
это бинарник расширенной системы, внештатные динамически связываемые библиотеки (dll),
каталог с исходниками непосредственно программы. 
Не надо копировать все библиотеки, или кропотливо выбирать только
используемы (они уже выбраны и собраны в бинарник).
Остается возможность модификации — наиболее часто изменяемая
часть программы берется из исходников. Запуск быстрей,
чем из начального ядра, т.к. мегабайты библиотек
уже собраны.
</p>

</chapter>

</book>
