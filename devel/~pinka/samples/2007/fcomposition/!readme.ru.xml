<?xml version="1.0" encoding="Windows-1251"?>
<?xml-stylesheet type="text/xsl" href="../notion/xhtml.xsl"?>
<book>
<!-- Apr.2008 ruvim@forth.org.ru — -->
<!-- $Id: !readme.ru.xml,v 1.12 2008/12/21 23:54:57 ruv Exp $ -->
<style>
  dd { margin-bottom: 0.7em; }
  dt { font-weight: bold; padding-top: 0.7em; }
</style>

<h2>fcomposition</h2>

<toc/>

<chapter id="intro"><title>Введение</title>
<p>
Целью данной работы, имеющей кодовое название «fcomposition», 
является отработка композиции и целевой сборки форт-системы.
Задача состоит в том, чтобы построить целевой транслятор,
не зависящий от деталей конкретной целевой форт-системы,
но принимающий эти детали на вход, как функция аргументы,
и порождающий целевую систему в <i>ее собственном виде</i>.
Для решения этой задачи надо провести целесообразную 
модуляризацию целевой системы в общем виде 
и согласовать внутреннии и внешнии интерфейсы.
</p><p>
В качестве примера, представим описание одного транслятора (форт-системы), порождающего байткод,
и описание второго транслятора, порождающего некоторый машинный код.
Тогда, наш целевой транслятор по описанию первого должен построить его в его собственном байткоде,
а по описанию второго построить его в том же машинном коде, который тот сам и порождает.
Тоже самое касается внутренних форматов словарей, контекстов, и т.п.
</p>
</chapter>

<chapter id="requirements"><title>Требования и ограничения</title>
<ol><li>Модули с определениями, составляющими целевую систему,
должны быть:
  <ol style="list-style-type: lower-greek">
       <li>свободны от выражений, специфичных для целевого транслятора;
  </li><li>свободны от немедленно исполняющегося кода (кроме особо оговореных случаев);
  </li><li>транслируемы обычным транслятором так же легко, как и целевым.
  </li></ol>
</li><li>При целевой сборке недопустимо прямое исполнение целевого кода
(но, допустима эмуляция).
</li></ol>
</chapter>

<chapter id="lyrics"><title>Лирика (опущена)</title>
<p>Лирику про то, что как и почему выбрано в качестве базовых элементов — опустим. Приступим к поверхностному изложению фактов :)</p>
</chapter>

<chapter id="target"><title>Характеристики целевой системы</title>
<p>При отработке общей композиции, реализация деталей роли не играет.
Для простоты, целевая система (которая описана в каталоге <w><a href="trial/">trial</a></w>) сделана <i>макетной:</i> формат откладываемого кода и все основные слова форт-процессора наследуются от инструментальной системы — SPF4 (импортируемые слова перечисляются в элементах <w>tc:import</w>).
Тем не менее, в системе реализуются собственные: <a href="trial/storage.f.xml">хранилище</a> (с опционально совмещенными или разделенными пространствами кода и данных), лексикон работы со строками, <a href="trial/codegen.f.xml">кодогенератор</a> (задает формат откладываемого кода) и <a href="trial/interpreter.f.xml">интерпретатор</a>, включающий форматы списков слов и контекста поиска. Также, есть интерпретирующий цикл <w>QUIT</w>.
Транслятор же в систему не включен — любой вариант транслятора реализуется на базе интерпретатора и кодогенератора, а цикла <w>QUIT</w> достаточно, чтобы расширить даже уже самостоятельно живущую систему транслятором.
Также, нету и никаких слов немедленного исполнения или заглядывающих вперед, т.к. они уместны только в контексте конкретной реализации транслятора.
</p><p>
  Все слова разбиты по тематическим спискам, и, кроме того, еще все свалены кучей в список <w>FORTH-WL</w> в отладочных целях (см. результат от <w>VOCS</w> и <w>WORDS</w>); при включении одного слова в несколько списков, они все для экономии разделяют одну копию текста имени. Разбиение сделано, чтобы было проще отсечь в контексте необходимые лексиконы — в SPF4 это трудно сделать, т.к. все свалено в единственную кучу. Отсекать надо, когда подставляется другая релизация лексикона и надо быть уверенным, что ничего случайно не попало из штатной реализации.  
</p><p>
  <a href="../../../model/data/wordlist-plain.f.xml">Список слов</a> наследует от 
  <a href="../../../model/data/list-plain.f.xml">простого списка</a>, 
  и над списками слов доступны операции, определенные для простых списков. Базовое представление строки наследует от представления блока данных ( addr u ), и над строками доступны операции блоков данных.
  Контекст поиска (<a href="../../../model/data/scope.static.f.xml">scope</a>) является стеком 
  и определен над <a href="../../../model/data/zstack.L1.immutable.f.xml">z-стеком</a>.
</p>
</chapter>

<chapter id="modularization"><title>Модуляризация</title>
<p>Форт-система разбита на следующие <a href="doc/modularization-picture.xml">модули</a> первого порядка: форт-процессор,
хранилище, кодогенератор, интерпретатор, транслятор. 
Такие детали, как библиотечные функции, лексиконы поддержки, интерфейс с внешними функциями — пока здесь не рассматриваются.
</p>
<p>
Каждый модуль представлен некоторым механизом (или несколькими). Механизмы могут быть вложенными (сложносоставными). Подробней о понятии механизма в применении к форту изложено в <a href="http://www.forth.org.ru/~mlg/COP-93/cop93.html">статье</a> и в <a href="http://www.forth.org.ru/~mlg/COP-93/cop-addendum.html">иллюстрации</a> Михаила Гасаненко на тему <acronym title="Context-Oriented Programming">COP</acronym>.
</p>

<dl>
<dt>Форт-процессор</dt>
<dd>
<p><small>Или, Forth Virtual Machine. «Процессор» понимается в логическом смысле, а не обязательно в железе.</small></p>
<p>Включает слова доступа к памяти, стекам (данных, возвратов, управления), логику, арифметику, вызов подпрограмм, обработку исключений (<w>CATCH</w>, <w>THROW</w>). Все слова реентерабельны, стеки локальны для потока в случае многопоточности.</p>
</dd>

<dt>Хранилище (и механизм хранилищ)</dt>
<dd><p>Хранилище логически включает пространство кода («кодофайл»), пространство данных и, возможно, другие пространства при необходимости. Логические пространства могут быть фактически совмещены в одном непрерывном адресном пространстве.
Все операции производятся с текущим хранилищем. Механизм хринилищ позволяет менять текущее хранилище (примерно так, как cd-привод пишет на текущий, вставленный в него диск, но диск можно сменить, сделать запись на другой, а потом дописывать на старый).
Лексикон доступа к пространству данных включает слова <w>HERE ALLOT , 2, B, C, S,</w>.
При наличии отдельного пространства кода, оно доступно через такой же лексикон в словаре <w>CODESPACE-WL</w>. Одноименный лексикон позволяет описанию кодогенератора независеть от того, совмещены или разделены пространства кода и данных. Также, это позволяет просто описать составное хранилище — как агрегацию нескольких <i>пространств данных</i>. Хранилища могут быть динамическими, ограниченными временем жизни процесса, или постоянными, имеющими свое место в сохраняемом образе.
Для смены хранилища служат слова: <w>SAVE-STORAGE</w>, <w>RESTORE-STORAGE</w>, <w>DATASPACE!</w>, <w>CODESPACE!</w>. 
</p><p>
  Варианты реализации механизма хранилищ включают: единственный механизм на процесс (разделяемый всеми через wait/release), локальный для потока (без разделения экзепляров хранилищ между экзеплярами механизмов), фабрику и пул механизмов (вкупе с трансляторами).
</p><p>
Пример реализации пространства данных: <a href="../../../model/data/data-space.immutable.f.xml">data/data-space.immutable.f.xml</a>,
механизма хранилища: <a href="trial/storage.f.xml">trial/storage.f.xml</a>.
</p>
</dd>

<dt>Кодогенератор</dt>
<dd><p>Позволяет создавать новые анонимные определения, представляемые токеном исполнения, и задавать их семантику. Семантика задается путем откладывания семантики исполнения других слов, чисел, строк, и откладывания элементов управления потоком исполнения (инкрементная компиляция). Пример реализации лексикона: <a href="../../../model/codegen/common.L2.f.xml">codegen/common.L2.f.xml</a>.
</p><p>
Кодогенератор описывается на базе механизма хранилища и определяет формат откладываемого кода.
</p>
</dd>

<dt>Интерпретатор</dt>
<dd><p>Отвечает за преобразование литералов чисел из строк, разрешение имен в токены, именование слов, создание списков слов, управление контекстом (<w>PUSH-SCOPE</w>, <w>POP-SCOPE</w>, <w>DROP-SCOPE</w>, <w>CLEAR-SCOPE</w>, <w>PUSH-CURRENT</w>, <w>DROP-CURRENT</w>, <w>PUSH-DEVELOP</w>, <w>POP-DEVELOP</w>, <w>DROP-DEVELOP</w>, <w>BEGIN-EXPORT</w>, <w>END-EXPORT</w>), интроспекция (<w>WORDS</w>, <w>VOCS</w>, <w>NLIST</w>, <w>ORDER</w>).</p>
<p>Интерпретатор использует механизмы списков (набор всех словарей), стеков (лексический контекст) и ассоциаций (связывание имен с токенами). Может использовать текущее хранилище для создания новых отношений.
</p>
</dd>

<dt>Транслятор</dt>
<dd><p>Отвечает за преобразование токенов в отложенный код или побочные эффекты, в зависимости от контекста, и за применение фрагментов исходного кода к форт-системе.</p>
<p>Транслятор объединяет кодогенератор и интерпретатор, которые между собой никак не связанны и ничего друг о друге не знают.</p>
</dd>

</dl>
</chapter>

<chapter id="bootstrapping"><title>Раскрутка</title>
<p>Сборка целевой форт-системы делается почти так же, как и <a href="http://en.wikipedia.org/wiki/Self-hosting#History">раскручивался компилятор Лиспа</a> :)
</p><p>
В инструментальную систему загружается механизм хранилища, кодогенератор и интерпретатор от целевой системы. Поверх них загружается транслятор от ForthML (метаФорт)<sup>*</sup>.
Далее, инициируется все необходимое, запускается ранее загруженный транслятор и в нем выполняется загрузка всей целевой системы. В результате, в хранилище оказывается целевая система в собранном виде и этот образ остается сохранить в исполняемый файл.
</p>
<p>Не слишком ли просто? Где же тут целевой транслятор? 
Загруженный экземпляр транслятора метаФорта<sup>*</sup> им по сути и является, т.к. порождает код в формате целевой системы. С формальной же точки зрения, вся операция сводится к функции TT, которая применяет аргумент к нему самому — <w>TT: t --> t(t)</w>, где <w>t</w> представляет собой целевую систему в исходном виде. 
Должно быть, в этой более сложной семантике и лежит отличие целевого от обычных компиляторов.
</p>
</chapter>



<chapter id="generator"><title>О целевом трансляторе</title>
<p>Ядро целевого транслятора описанно в файле <w><a href="tc-host.f.xml">tc-host.f.xml</a></w>. Слово «host» в имени файла намекает на основу и на отношение хозяин-гость. Здесь  целевой транслятор — хозяин, и загружаемая целевая система является гостевой по отношению к нему. Данное ядро задает основные отношения между составляющими его модулями, определяя абстрактную структуру.
Заданные там <w>#storage</w>, <w>#codegen</w>, <w>#interpreter</w> — это и есть формальные параметры, определяющие детали целевой системы.
</p>
<p> Как оказалось, это ядро — самая маленькая и в тоже время самая сложная часть данной раскрутки. Основная трудность связанна с тем, что при воплощении модели этого ядра в контексте находятся как лексиконы инструментальной системы так и перекрывающие их лексиконы формируемой хост-системы, и надо отслеживать, чтобы нигде не произошло ошибочной подмены. 
</p><p>
При загрузке гостевой системы дело обстоит значительно проще: благодаря использованию метаФорта, в контексте доступны только уже созданные слова самой гостевой системы и ничего более! Это дает значительное упрощение по сравнению с раскруткой SPF4.
</p>
</chapter>
  
<chapter id="conclusion"><title>Заключение</title>
<p>Данная реализация целевой сборки форт-системы 
абстрагирована от способа реализации в целевой системе:
хранилища, кодогенератора, интерпретатора, — и всего остального, что на них основано.
Но, она завязана на размер ячейки и размер символа: в целевой системе они должны быть такие же, как в инструментальной. Это связано с тем, что размер ячейки — это уровень форт-процессора, а эффективная реализация форт-процессора (если его нет в железе) делается иными средствами, без использования слов форт-процессора в определениях (да ведь их «еще и нету»).
</p><p>
Для того, чтобы собрать целевую систему с иной размерностью ячейки (или символа),
надо в целевом трансляторе, до загрузки механизма хранилища,
загрузить эмулятор целевого форт-процессора: слова работы со стеком и памятью требуемой разрядности, реализованные средствами инструментальной системы.
</p>
</chapter>

<chapter id="files"><title>Приложение: назначение файлов</title>
<dl>

<dt><w><a href="envir.f.xml">envir.f.xml</a></w></dt>
<dd>окружение для целевого транслятора, используемые библиотеки;</dd>

<dt><w><a href="tc-host.f.xml">tc-host.f.xml</a></w></dt>
<dd>целевой транслятор (по старинке «tc»);</dd>

<dt><w><a href="carcase.f.xml">carcase.f.xml</a></w></dt>
<dd>каркас целевой форт-системы, все крупные блоки (лексиконы) с разбивкой по словарям;</dd>

<dt><w><a href="model.f.xml">model.f.xml</a></w></dt>
<dd>ссылается на <w>model-trial.f.xml</w>;</dd>

<dt><w><a href="model-trial.f.xml">model-trial.f.xml</a></w></dt>
<dd>испытательный состав целевой макетной системы;</dd>

<dt><w><a href="trial/">trial/</a></w></dt>
<dd>конкретная реализация лексиконов целевой системы;</dd>

<dt><w><a href="import-words.f.xml">import-words.f.xml</a></w></dt>
<dd>импорт слов из инструментальной системы в целевую;</dd>

<dt><w><a href="quit.f.xml">quit.f.xml</a></w></dt>
<dd>простейший цикл <w>QUIT</w> в целевой системе;</dd>

<dt><w><a href="index.f.xml">index.f.xml</a></w></dt>
<dd>сборка и инициализация целевой системы;</dd>

<dt><w><a href="index.f">index.f</a></w></dt>
<dd>корневой скрипт: загрузка библиотек, целевого транслятора, сборка и запуск целевой системы.</dd>

</dl>
</chapter>

</book>
