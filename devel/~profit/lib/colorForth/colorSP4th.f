\ colorlessForth без цвета. Идеи -- Chuck Moore и Terry Loveall.
\ Режим компиляции убирается. Остаётся только интерпретация.

\ Мур определелил colorForth как "обычный исходный текст, где
\ пунктуация обозначается цветом". В рамках более технологичного
\ с точки зрения формата исходных текстов colorlessForth-подхода
\ не может не возникнуть вопрос: "а зачем придумывать несовместимые
\ (с текстовым форматом хранения исходников) цвета, для замены 
\ пунктуации если можно использовать саму пунктуацию 
\ непосредственно?"

\ Главный ориентиром при реализации принималась следующая
\ концепт-строчка форт-текстов с явно выражаемой пунктуацией:

\ заголовок: слово, слово, слово.

\ При этом автор в угоду этой общей логике построения обычных 
\ предложений (перечисление через обычную запятую, последний 
\ элемент отмечается точкой) сознательно игнорирует сложившуюся
\ фортовскую этимологию (запятая и точка в обычном форте 
\ имеют совершенно иной смысл).


\ Технически это выглядит так:
\ Во время анализа каждого отдельного слова (изменений в логике
\ обработки строк и файлов по сравнению со стандартным в SPF нет),
\ интерпретатор сперва пытается разрешить слово в рамках его 
\ понятий, если ему это удаётся, то специфическая обработка 
\ пунктуации отдыхает. Если же нет, то вступает в действие следующий
\ алгоритм:

\ Что делать со "словом" (точнее говоря, строкой), определяется
\ последней буквой:

\ : -- определение
\ , -- компиляция ( COMPILE, )
\ . -- компиляция безусловного перехода ( BRANCH, ), хвостовая оптимизация
\ ; -- компиляция числового литерала ( LIT, )
\ ' -- трактовка строки как имени слова, у которого нужно выяснить xt
\ | -- запись в кодофайл числа ( | )
\ # -- десятичное число
\ $ -- шестнадцатиричное число

\ : r          -->  r:
\ : r 12 ;     -->  r: 12; .
\ ' r          -->  r'
\ ' r COMPILE, -->  r' , --> r,
\ ['] r        -->  r;
\ ' r ,        -->  r,
\ : r 0x32 ;   -->  r: 32$; .

\ Также надо отметить что у "цветов" . , ; | есть их аналоги-слова
\ которые свои аргументы (если есть) берут со стека.

\ Таким образом можно явно выражать наше нежелание компилировать
\ хвостовую оптимизацию:
\ DUP. --> DUP, .

\ См. также ~profit\lib\loveall.f

\ square: DUP, *.
\ 2x2: 2#; square, typeNumber.
\ 2x2

\ Интерпретатор сначала пытается исполнить пришедшее слово
\ непосредственно, если такого слова нет, то начинает анализ,
\ отделяя последнюю букву от остальной части слова и посылая
\ эти данные в отдельный обработчик для каждой буквы-"цвета"
\ а он там сам может со строкой-остальной частью слова 
\ что-нибудь сделать.

\ Таким образом, в этой реализации colorlessForth'а убирается за 
\ более ненужностью не только STATE но и IMMEDIATE .

\ В обмен получаем не только существенное упрощение в логике 
\ интерпретации но и возможность написания кода на более "высоких"
\ слоях одновременно без нарушения работы нижних.

\ Это делается через так называемый "перехват" режимов.

\ Например, определив слово "SWAP," можно задать действия по компиляции
\ SWAP (оптимизация какая-нибудь). При этом само слово "SWAP" остаётся
\ совершенно незадетым и ' SWAP (или SWAP' , с пунктуацией) выдаёт 
\ именно то что надо.

\ Или более того -- можно определить слово с именем "r:"
\ для перехвата определения слова r

\ r::  bam" TYPE, r" :.

\ Или можно добавить специальную обработку хвостового вызова
\ слова:

\ r.:  tail!" TYPE, r' BRANCH,.

\ чтобы отловить момент создания 

\ TODO:
\ 1. Сделать совместимость с cascaded.f
\ 2. Возможно, стоит в обработчик all: сделать "правильный" выход из nf-ext 
\ (на выходе после неудачной обработки должно быть addr u FALSE, для передачи
\ следующим обработчикам nf-ext)
\ 3. Решить вопрос со строками (цвет " логичен, но как быть с многословными
\ строками?)
\ 4. Корявое название typeNumber
\ 5. Строковые литералы. Пока -- цветом ". Причём цвет этот неэлементарен,
\ так как он предполагает компиляцию.

\ Соответствие кода с пунктуацией обычному:
\ определение:  1#; typeNumber,    <--- CREATE определение 1 LIT, COMPILE .
\ определение2: 2#; typeNumber,    <--- CREATE определение 2 LIT, COMPILE .
\ определение3: 3#; typeNumber, .    <--- CREATE определение 3 LIT, COMPILE . RET,
\ определение3: 3#; typeNumber.    <--- CREATE определение 3 LIT, ' . BRANCH,

REQUIRE /TEST ~profit/lib/testing.f
REQUIRE NOT ~profit/lib/logic.f
REQUIRE (: ~yz/lib/inline.f
REQUIRE lastChar ~profit/lib/strings.f
REQUIRE number ~profit/lib/number.f
REQUIRE charTable ~profit/lib/chartable-eng.f
REQUIRE enqueueNOTFOUND ~pinka/samples/2006/core/trans/nf-ext.f
REQUIRE KEEP! ~profit/lib/bac4th.f
\ REQUIRE cascaded ~profit/lib/colorForth/cascaded.f

MODULE: colorSPF

: wordCode ( addr u -- ) SFIND NOT IF 2DROP -321 THROW  THEN ;
: numberOrWord ( addr u -- ) SFIND NOT IF
lastChar [CHAR] # = IF 10 BASE KEEP! CHAR- THEN CHAR+
lastChar [CHAR] $ = IF 16 BASE KEEP! CHAR- THEN CHAR+
number THEN ;

charTable colors

colors
all: -321 THROW ;
char: ' wordCode ;
char: , wordCode COMPILE, ;
\ char: : CREATED DOES> EXECUTE ;
char: : SHEADER ;
char: . wordCode BRANCH, ;
char: " SLIT, ; \ "
char: ; numberOrWord  LIT, ;
char: | numberOrWord , ;

(
ALSO cascaded
\ режим каскадных определений выкидывает словарные структуры
\ из кодофайла

NEW: CSPFWords
\ заводим общий словарь для слов CSPF
PREVIOUS )

: processWord ( addr u -- ) lastChar colors processChar ;

EXPORT

\ Перехват NOTFOUND-действия для случая "::" -- чтобы не срабатывала логика vocabulary::word
: NOTFOUND
2DUP S" ::" COMPARE 0= IF processWord EXIT THEN 
NOTFOUND ;

: startColorSPF
(: ( addr u -- addr u false | i*x true ) processWord TRUE ;) enqueueNOTFOUND
\ [COMPILE] ]
\ ALSO CSPFWords DEFINITIONS
;

: typeNumber . ; \ чтобы можно было обратиться к точке без коллизий с существующим в ядре словом ..

;MODULE

/TEST
REQUIRE SEE lib/ext/disasm.f

startColorSPF

.: RET,.
;: LIT,.
|: ,.
,: COMPILE,.
": SLIT,.
:: SHEADER.

\ В следствие того что цвет компиляции ( , ) знать 
\ ничего не хочет про IMMEDIATE-статус, то нужно 
\ задавать действие "во время компиляции if"
IF,:   TRUE, STATE, KEEP!, IF.
THEN,: TRUE, STATE, KEEP!, THEN.

\ INLINE-подстановочные слова (src/compiler/spf_inline.f)
RDROP,:   TRUE, STATE, KEEP!, RDROP.
?DUP,:    TRUE, STATE, KEEP!, ?DUP.
EXECUTE,: TRUE, STATE, KEEP!, EXECUTE.

>R,:  TRUE, STATE, KEEP!, >R.
R>,:  TRUE, STATE, KEEP!, R>.

>R:   >R, .
R>:   R>, .



\ ."' .": TRUE, STATE, KEEP!, , .

fact: ( x -- fx ) ?DUP, 0=, IF, 1; . THEN, DUP, 1-, fact, *.

$> SEE fact
$> 4 fact typeNumber

array: R>.

arr: array,
0| 1| 2| 3| 4| 5|

$> arr 6 CELLS DUMP