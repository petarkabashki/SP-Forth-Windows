Для заданного числа um, представляющего собой битовую маску,
найти все варианты битовых сочетаний, таких что,
операция логического И с инверсной маской в результате вернет 0:
: test  ( u mask --> flag ) INVERT AND ;
(То есть смысл фактически в том, чтобы биты двоичного счетчика
раздвинуть так, чтобы они располагались в местах, где единички
в маске стоят).

пример:
для маски b0011 должны получиться следующие значения: b0000 b0001 b0010 b0011;
для маски b1001 -- следующие: b0000 b0001 b1000 b1001;
для маски b0110 -- b0000 b0010 b0100 b0110; и так далее

Найти за минимальное время все возможные комбинации бит внутри маски um,
сохранить их в массиве.

Размер маски 1 CELL, битовое заполнение маски не может превышать 25% величины.
